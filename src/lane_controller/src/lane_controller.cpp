/*************************************************
 *  lane_controller.cpp
 *  
 *  Uses error measurements from the pose estimate
 *  generated by pose_estimate.cpp to control the steering
 *  of the vehicle using a PID controller.
 *
 *  Subscribers: pose_estimate
 *  Publishers: N/A
 *
 *  Author: Zachary Kendrick
 ************************************************/

#include <ros/ros.h>
#include <sstream>
#include <cv_bridge/cv_bridge.h>
#include <opencv/cv.h>
#include <opencv/highgui.h>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/objdetect/objdetect.hpp>
#include <visualization_msgs/Marker.h>
#include <tf2/LinearMath/Quaternion.h>
#include <math.h>
#include <sys/time.h>
#include <opencv-3.1.0-dev/opencv2/plot.hpp>
#include <std_msgs/Float64MultiArray.h>

using namespace cv;
using namespace std;
using namespace ros;


// PID coefficients
const static float K_P = 0.0;
const static float K_I = 0.0;
const static float K_D = 0.0;

// past time and error
float last_disp_err = 0.0;
long past_time;
float err_I;

// car pose publisher
ros::Publisher pwm_pub;



/*
   Function:
      Call back function that reads a pose from
      "pose_estimate" topic and produces PWM signals
      for the robot motors from a PID loop.
   Parameters:
      const visualization_msgs::MarkerConstPtr& msg - "pose_estimate" message
   Publishes:
      pwm array data[0]-left motor, data[1]-right motor
*/

void PID(const visualization_msgs::MarkerConstPtr& msg) {

    // get the error in the angle of the pose
    tf2::Quaternion quat(msg->pose.orientation.x, msg->pose.orientation.y, msg->pose.orientation.z, msg->pose.orientation.w);
    float angle_err = quat.getAngle() - M_PI;

    // get the error in the displacement of the pose
    float disp_err = msg->pose.position.y;

    // calculate time ellapsed
    timeval time;
    gettimeofday(&time, NULL);
    long present_time = (time.tv_sec * 1000) + (time.tv_usec / 1000);
    float dt = (float)(present_time - past_time);

    // calculate I and D error
    err_I += (disp_err * dt);
    float err_D = (disp_err - last_disp_err)/dt;

    // compute PID output
    float output = K_P*disp_err + K_I*err_I + K_D*err_D;

    /*Remember some variables for next time*/
    last_disp_err = disp_err;
    past_time = present_time;

    cout << "HELLO" << endl;
    // publish the PWMs from the PID output
    std_msgs::Float64MultiArray motor_pwm;
    motor_pwm.data.push_back(0.3);//left_motor_pwm;
    motor_pwm.data.push_back(0.7);//right_motor_pwm;
    cout << motor_pwm << endl;
    pwm_pub.publish(motor_pwm);

}


int main(int argc, char **argv)
{
    ros::init(argc, argv, "lane_controller");
    ros::NodeHandle nh;
    // cv::namedWindow("histogram");
    // cv::startWindowThread();

    // intialize the past time
    timeval t;
    gettimeofday(&t, NULL);
    past_time = (t.tv_sec * 1000) + (t.tv_usec / 1000);

    // subscribe to the "raw_image" topic
    ros::Subscriber pose_sub = nh.subscribe("pose_estimate", 1, PID);

    // publish the pwm of the motors
    pwm_pub = nh.advertise<std_msgs::Float64MultiArray>("motor_pwm", 1);

    ros::Rate r(30);
    ros::spin();
    cv::destroyWindow("histogram");
}